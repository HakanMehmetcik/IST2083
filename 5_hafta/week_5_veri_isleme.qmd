---
title: "week_5_veri_isleme"
author: "Hakan Mehmetcik"
date: "2024-10-31"
format: pdf
editor: visual
execute: 
  echo: true
  warning: true
---

```{r setup, echo=FALSE, message=FALSE}
# loaded packages
library(here)
library(tidyverse)
library(ggplot2)
library(mdsr)
library(mosaicData)
library(fec16)
library(nycflights13)

here <- here::here()
dpath <- "data"
```

# Veri DÃ¼zenleme iÃ§in Bir Dilbilgisi

TÄ±pkÄ± `ggplot2` paketinin veri gÃ¶rselleÅŸtirme iÃ§in gÃ¼Ã§lÃ¼ ve esnek bir dilbilgisi sunmasÄ± gibi, `dplyr` paketi de R programlama dilinde veri manipÃ¼lasyonu ve dÃ¼zenleme iÅŸlemleri iÃ§in son derece kullanÄ±ÅŸlÄ± ve etkili bir dilbilgisi sunar. Bu paket, veri analizi sÃ¼recini daha verimli ve anlaÅŸÄ±lÄ±r hale getiren bir dizi araÃ§ saÄŸlar.

Ã–zellikle, `dplyr` paketi veri Ã§erÃ§eveleri Ã¼zerinde Ã§eÅŸitli karmaÅŸÄ±k iÅŸlemler gerÃ§ekleÅŸtirmek iÃ§in "fiil" olarak adlandÄ±rÄ±lan iÅŸlevsel fonksiyonlar sunar. Bu fiiller, veri setlerini filtreleme, sÄ±ralama, gruplama, Ã¶zetleme ve birleÅŸtirme gibi temel veri manipÃ¼lasyon gÃ¶revlerini gerÃ§ekleÅŸtirmek iÃ§in kullanÄ±lÄ±r. Her bir fiil, belirli bir gÃ¶revi yerine getirmek Ã¼zere tasarlanmÄ±ÅŸtÄ±r ve birbirleriyle kolayca birleÅŸtirilebilir, bÃ¶ylece karmaÅŸÄ±k veri dÃ¶nÃ¼ÅŸÃ¼mlerini bile anlaÅŸÄ±lÄ±r ve okunabilir bir ÅŸekilde ifade etmek mÃ¼mkÃ¼n olur.

::: callout-note
**ğŸ’¡** `dplyr` paketindeki temel fiiller ÅŸunlardÄ±r:

-   `select()`: Veri Ã§erÃ§evesinden belirli sÃ¼tunlarÄ± seÃ§mek iÃ§in kullanÄ±lÄ±r.

-   `filter()`: Belirli koÅŸullarÄ± saÄŸlayan satÄ±rlarÄ± seÃ§mek iÃ§in kullanÄ±lÄ±r.

-   `mutate()`: Yeni sÃ¼tunlar oluÅŸturmak veya mevcut sÃ¼tunlarÄ± deÄŸiÅŸtirmek iÃ§in kullanÄ±lÄ±r.

-   `arrange()`: Veri Ã§erÃ§evesindeki satÄ±rlarÄ± belirli sÃ¼tunlara gÃ¶re sÄ±ralamak iÃ§in kullanÄ±lÄ±r.

-   `summarize()`: Verileri satÄ±rlar arasÄ±nda Ã¶zetlemek iÃ§in kullanÄ±lÄ±r.

Bu fiilleri birleÅŸtirerek karmaÅŸÄ±k veri manipÃ¼lasyon iÅŸlemlerini kolayca gerÃ§ekleÅŸtirebilirsiniz. `dplyr` paketi, R ile veri analizi yapan herkes iÃ§in olmazsa olmaz bir araÃ§tÄ±r. Bu paketin sunduÄŸu dilbilgisi yaklaÅŸÄ±mÄ±, veri manipÃ¼lasyonunu daha kolay, anlaÅŸÄ±lÄ±r ve etkili hale getirir.
:::

## 1. select() ve filter()

-   **`select()`**: Veri Ã§erÃ§evesinden belirli **sÃ¼tunlarÄ±** seÃ§mek iÃ§in kullanÄ±lÄ±r. Ã–rneÄŸin, `select(veri, sutun1, sutun2)` kodu, `veri` adlÄ± veri Ã§erÃ§evesinden sadece `sutun1` ve `sutun2` adlÄ± sÃ¼tunlarÄ± seÃ§er. Bu fonksiyon, veri setinizi sadeleÅŸtirmek ve sadece ihtiyacÄ±nÄ±z olan deÄŸiÅŸkenleri tutmak iÃ§in faydalÄ±dÄ±r.

-   **`filter()`**: Belirli koÅŸullarÄ± saÄŸlayan **satÄ±rlarÄ±** seÃ§mek iÃ§in kullanÄ±lÄ±r. Ã–rneÄŸin, `filter(veri, sutun1 > 10)` kodu, `veri` veri Ã§erÃ§evesinde `sutun1` deÄŸerleri 10'dan bÃ¼yÃ¼k olan satÄ±rlarÄ± filtreler. Bu fonksiyon, analiziniz iÃ§in belirli kriterleri karÅŸÄ±layan gÃ¶zlemleri seÃ§menize olanak tanÄ±r.

```{r}
presidential |> 
  select(name, party)
  
```

::: callout-note
ğŸ‘‹ `tidyverse` iÃ§indeki `pipe` operatÃ¶rÃ¼ (`|>`) veri manipÃ¼lasyonunu ve analizini kolaylaÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r. Kodunuzu daha okunabilir ve anlaÅŸÄ±lÄ±r hale getirir.

**`pipe` OperatÃ¶rÃ¼ NasÄ±l Ã‡alÄ±ÅŸÄ±r?**

`pipe` operatÃ¶rÃ¼ (`|>`), bir fonksiyonun Ã§Ä±ktÄ±sÄ±nÄ± bir sonraki fonksiyonun girdisi olarak kullanmanÄ±za olanak tanÄ±r. Bu sayede, iÃ§ iÃ§e geÃ§miÅŸ fonksiyonlar yerine, iÅŸlemleri adÄ±m adÄ±m zincirleme bir ÅŸekilde yazabilirsiniz.
:::

```{r}
presidential |> 
  filter(party=="Republican")
```

`select` ve `filter`'Ä± birlikte kullanmaya ne dersiniz?

```{r}
presidential |> 
  select(name, party) |> 
  filter(party=="Republican") 

```

`filter()` ve `select()` komutlarÄ±nÄ± birleÅŸtirmek, Ã§ok belirli bilgilere ulaÅŸmayÄ± saÄŸlar. Ã–rneÄŸin, presidential veri setinde Watergate skandalÄ±ndan beri gÃ¶rev yapan Demokrat baÅŸkanlarÄ± bulabiliriz.

```{r}
presidential |> 
  filter(year(start) > 1973 & party == "Democratic") |> 
  select(name)
```

## 2. mutate() ve rename()

Veri analizi yaparken sÄ±klÄ±kla verilerimiz Ã¼zerinde deÄŸiÅŸiklikler yapmamÄ±z gerekir. Bu deÄŸiÅŸiklikler, yeni deÄŸiÅŸkenler oluÅŸturmayÄ±, mevcut deÄŸiÅŸkenleri yeniden tanÄ±mlamayÄ± veya deÄŸiÅŸkenlerin isimlerini deÄŸiÅŸtirmeyi iÃ§erebilir. `dplyr` paketi, `mutate()` ve `rename()` fonksiyonlarÄ± ile bu iÅŸlemleri kolayca yapmamÄ±zÄ± saÄŸlar.

Ã–rneÄŸin, elimizde ABD baÅŸkanlarÄ±nÄ±n gÃ¶rev sÃ¼relerine iliÅŸkin bir veri setimiz olan presidential verisini dÃ¼ÅŸÃ¼nelim. Bu veri setinde, her baÅŸkanÄ±n gÃ¶reve baÅŸlama ve gÃ¶revden ayrÄ±lma tarihleri bulunmaktadÄ±r. Ancak, her baÅŸkanÄ±n gÃ¶rev sÃ¼resinin uzunluÄŸunu gÃ¶steren bir deÄŸiÅŸken yoktur. `mutate()` fonksiyonunu kullanarak, bu bilgiyi mevcut tarihlerden hesaplayabilir ve veri setimize yeni bir sÃ¼tun olarak ekleyebiliriz.

::: callout-note
âš ï¸ Mevcut veri setini deÄŸiÅŸtirmek yerine, genellikle yeni bir veri seti oluÅŸturmak iyi bir uygulamadÄ±r. Bu sayede, orijinal veri setini koruyabilir ve Ã¼zerinde istediÄŸiniz deÄŸiÅŸiklikleri yapabilirsiniz. Ã–rneÄŸin, `mutate()` fonksiyonunun Ã§Ä±ktÄ±sÄ±nÄ± yeni bir veri setine kaydedebilirsiniz.
:::

```{r}
my_presidents <- presidential |>
  mutate(term.length = interval(start, end) / dyears(1))
head(my_presidents) 
```

`mutate()` fonksiyonu, mevcut bir sÃ¼tundaki verileri deÄŸiÅŸtirmek iÃ§in de kullanÄ±labilir. Ã–rneÄŸin, veri Ã§erÃ§evemize her baÅŸkanÄ±n seÃ§ildiÄŸi yÄ±lÄ± iÃ§eren bir deÄŸiÅŸken eklemek istediÄŸimizi dÃ¼ÅŸÃ¼nelim. Ä°lk (basit) yaklaÅŸÄ±mÄ±mÄ±z, her baÅŸkanÄ±n gÃ¶reve baÅŸlamadan Ã¶nceki yÄ±l seÃ§ildiÄŸini varsayabilir. `mutate()` fonksiyonunun bir veri Ã§erÃ§evesi dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼ unutmayÄ±n. Bu nedenle, mevcut veri Ã§erÃ§evemizi deÄŸiÅŸtirmek istiyorsak, onu yeni sonuÃ§larla gÃ¼ncellememiz gerekir.

```{r}
my_presidents <- my_presidents |>
  mutate(elected = year(start) - 1)
head(my_presidents) 
```

`rename()` fonksiyonu ise, deÄŸiÅŸkenlerin isimlerini deÄŸiÅŸtirmek iÃ§in kullanÄ±lÄ±r.

```{r}
my_presidents <- my_presidents |>
  rename(term_length = term.length)
head(my_presidents) 
```

::: callout-note
ğŸ’¡ `janitor` paketi, R ile veri temizleme iÅŸlemlerini kolaylaÅŸtÄ±rmak iÃ§in geliÅŸtirilmiÅŸ kullanÄ±ÅŸlÄ± bir pakettir. Ã–zellikle deÄŸiÅŸken isimlerini temizlemek ve dÃ¼zenlemek iÃ§in sunduÄŸu `clean_names()` fonksiyonu oldukÃ§a faydalÄ±dÄ±r.

**`clean_names()` fonksiyonu ne iÅŸe yarar?**

`clean_names()` fonksiyonu, veri setinizdeki deÄŸiÅŸken isimlerini otomatik olarak temizler ve standart bir formata dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. Bu sayede, deÄŸiÅŸken isimleriyle Ã§alÄ±ÅŸmak daha kolay hale gelir ve kodunuz daha okunabilir olur.

**`clean_names()` fonksiyonu hangi iÅŸlemleri yapar?**

-   **BÃ¼yÃ¼k/kÃ¼Ã§Ã¼k harf dÃ¶nÃ¼ÅŸÃ¼mÃ¼:** TÃ¼m harfleri kÃ¼Ã§Ã¼k harfe dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.

-   **BoÅŸluklarÄ±n kaldÄ±rÄ±lmasÄ±:** DeÄŸiÅŸken isimlerindeki boÅŸluklarÄ± kaldÄ±rÄ±r veya alt Ã§izgi (\_) ile deÄŸiÅŸtirir.

-   **Ã–zel karakterlerin kaldÄ±rÄ±lmasÄ±:** Noktalama iÅŸaretleri ve diÄŸer Ã¶zel karakterleri kaldÄ±rÄ±r veya alt Ã§izgi (\_) ile deÄŸiÅŸtirir.

-   **SayÄ±larÄ±n eklenmesi:** DeÄŸiÅŸken isimlerinin baÅŸÄ±na veya sonuna sayÄ±lar ekler (eÄŸer aynÄ± isimde birden fazla deÄŸiÅŸken varsa).

-   **Standart formata dÃ¶nÃ¼ÅŸtÃ¼rme:** DeÄŸiÅŸken isimlerini "snake_case" (alt Ã§izgi ile ayrÄ±lmÄ±ÅŸ kÃ¼Ã§Ã¼k harfli kelimeler) gibi standart bir formata dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.

**`clean_names()` fonksiyonu nasÄ±l kullanÄ±lÄ±r?**

`clean_names()` fonksiyonunu kullanmak iÃ§in Ã¶ncelikle `janitor` paketini yÃ¼klemeniz gerekir:

install.packages("janitor")

library(janitor)
:::

## 3. arrange()

Temel bir R fonksiyonu olan `sort()` fonksiyonu bir vektÃ¶rÃ¼ sÄ±ralar, ancak bir veri Ã§erÃ§evesini sÄ±ralamaz. `arrange()` fonksiyonu ise bir veri Ã§erÃ§evesini sÄ±ralar. `arrange()` fonksiyonunu bir veri Ã§erÃ§evesinde kullanmak iÃ§in, veri Ã§erÃ§evesini ve sÄ±ralamak istediÄŸiniz sÃ¼tunu belirtmeniz gerekir. AyrÄ±ca, sÄ±ralama yÃ¶nÃ¼nÃ¼ de belirtmeniz gerekir. Birden Ã§ok sÄ±ralama koÅŸulu belirtmek, eÅŸitlikleri Ã§Ã¶zmeye yardÄ±mcÄ± olur.

```{r}
my_presidents |>
  arrange(desc(term_length))
```

BaÅŸkanlÄ±k veri Ã§erÃ§evemizi her baÅŸkanÄ±n gÃ¶rev sÃ¼resinin uzunluÄŸuna gÃ¶re sÄ±ralamak iÃ§in, term_length sÃ¼tununun azalan sÄ±rada olmasÄ±nÄ± belirtiyoruz. AyrÄ±ca, parti ve seÃ§ilme yÄ±lÄ±na gÃ¶re de sÄ±ralama yapabiliriz.

```{r}
my_presidents |>
  arrange(desc(term_length), party, elected)
```

## 4. summarize() ve group_by()

Tek tablo analizi iÃ§in beÅŸ fiilimizden sonuncusu, neredeyse her zaman group_by() ile birlikte kullanÄ±lan summarize()'dÄ±r. Ã–nceki dÃ¶rt fiil, bir veri Ã§erÃ§evesini gÃ¼Ã§lÃ¼ ve esnek ÅŸekillerde iÅŸlemek iÃ§in bize araÃ§lar saÄŸladÄ±. Ancak yalnÄ±zca bu dÃ¶rt fiille gerÃ§ekleÅŸtirebileceÄŸimiz analizlerin kapsamÄ± sÄ±nÄ±rlÄ±dÄ±r. group_by() ile birlikte summarize() kullanmak ise bize karÅŸÄ±laÅŸtÄ±rmalar yapma imkanÄ± sunar.

```{r}
my_presidents |>
  summarize(
    N = n(), 
    first_year = min(year(start)), 
    last_year = max(year(end)), 
    num_dems = sum(party == "Democratic"), 
    years = sum(term_length), 
    avg_term_length = mean(term_length)
  )
```

Sonraki iki deÄŸiÅŸken, bu baÅŸkanlardan birinin gÃ¶reve baÅŸladÄ±ÄŸÄ± ilk yÄ±lÄ± ve en son baÅŸkanÄ±n gÃ¶revinin bittiÄŸi yÄ±lÄ± belirler. Ä°lki, `start` sÃ¼tunundaki en kÃ¼Ã§Ã¼k yÄ±l, ikincisi ise `end` sÃ¼tunundaki en bÃ¼yÃ¼k yÄ±ldÄ±r. `num_dems` deÄŸiÅŸkeni, `party` deÄŸiÅŸkeninin "Democratic" olduÄŸu satÄ±r sayÄ±sÄ±nÄ± sayar. Son iki deÄŸiÅŸken ise `term_length` deÄŸiÅŸkeninin toplamÄ±nÄ± ve ortalamasÄ±nÄ± hesaplar. SonuÃ§lar gÃ¶steriyor ki, 1953'ten 2021'e kadar gÃ¶rev yapan 12 baÅŸkandan 5'i Demokrat'tÄ±r ve bu 68 yÄ±llÄ±k dÃ¶nemde ortalama gÃ¶rev sÃ¼resi yaklaÅŸÄ±k 5,6 yÄ±ldÄ±r.

```{r}
my_presidents |>
  group_by(party) |>
  summarize(
    N = n(), 
    first_year = min(year(start)), 
    last_year = max(year(end)), 
    num_president = sum(party == "Democratic" | party == "Republican"), 
    years = sum(term_length), 
    avg_term_length = mean(term_length)
  )
```

## Dplyr iÃ§in bir ek Ã¶rnek

Bu Ã¶rnekte `dplyr`'Ä±n temel veri iÅŸleme fiillerini keÅŸfetmek iÃ§in `nycflights13::flights` veri setini kullanacaÄŸÄ±z. Bu veri Ã§erÃ§evesi, 2013 yÄ±lÄ±nda New York ÅŸehrinden kalkan 336.776 uÃ§uÅŸun tamamÄ±nÄ± iÃ§erir. Veriler ABD UlaÅŸtÄ±rma Ä°statistikleri BÃ¼rosu'ndan alÄ±nmÄ±ÅŸtÄ±r ve `?flights` komutu ile dokÃ¼mantasyonuna eriÅŸebilirsiniz.

### 1. filter()

```{r}
head(flights)
```

```{r}
jan1 <- flights |> 
  filter(month == 1, day == 1)
head(jan1)
```

::: callout-note
**R'da KullanÄ±lan Boolean operatÃ¶rler**

![](images/boolean_operators.png)
:::

AÅŸaÄŸÄ±daki kod, KasÄ±m veya AralÄ±k aylarÄ±nda kalkan tÃ¼m uÃ§uÅŸlarÄ± bulur:

```{r}
flights |> 
  filter(month == 11 | month == 12) |> 
  head()
```

::: callout-note
Bu kod iÃ§in kullanÄ±ÅŸlÄ± bir kÄ±saltma `x %in% y`'dir. Bu, `x`'in `y` iÃ§indeki deÄŸerlerden biri olduÄŸu her satÄ±rÄ± seÃ§ecektir. YukarÄ±daki kodu yeniden yazmak iÃ§in kullanabiliriz:
:::

```{r}
nov_dec <- filter(flights, month %in% c(11, 12))
```

De Morgan yasasÄ±nÄ± hatÄ±rlayarak karmaÅŸÄ±k alt kÃ¼meleme iÅŸlemlerini basitleÅŸtirebilirsiniz. Bu matematiksel kural, mantÄ±ksal ifadelerin dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼ saÄŸlar ve veri analizinde oldukÃ§a kullanÄ±ÅŸlÄ±dÄ±r. Ä°ki temel dÃ¶nÃ¼ÅŸÃ¼m ÅŸu ÅŸekildedir:

1.  `!(x & y)`, `!x | !y` ile aynÄ±dÄ±r: Bu, "x ve y'nin deÄŸili" ifadesinin "x'in deÄŸili veya y'nin deÄŸili" ile eÅŸdeÄŸer olduÄŸunu gÃ¶sterir.

2.  `!(x | y)`, `!x & !y` ile aynÄ±dÄ±r: Bu da "x veya y'nin deÄŸili" ifadesinin "x'in deÄŸili ve y'nin deÄŸili" ile eÅŸdeÄŸer olduÄŸunu belirtir.

Bu kurallar, karmaÅŸÄ±k sorgularÄ± basitleÅŸtirmek ve daha etkili hale getirmek iÃ§in kullanÄ±labilir. Ã–rneÄŸin, havayolu verilerini analiz ederken, varÄ±ÅŸta veya kalkÄ±ÅŸta iki saatten fazla gecikmeyen uÃ§uÅŸlarÄ± bulmak istiyorsanÄ±z, ÅŸu iki filtreden birini kullanabilirsiniz:

```{r}
flights |> 
  filter((arr_delay > 120 | dep_delay > 120))
flights |> 
  filter(arr_delay <= 120, dep_delay <= 120)
```

::: callout-note
âš ï¸ `filter()` yalnÄ±zca koÅŸulun DOÄRU olduÄŸu satÄ±rlarÄ± iÃ§erir; hem YANLIÅ hem de NA deÄŸerlerini hariÃ§ tutar. Eksik deÄŸerleri korumak istiyorsanÄ±z, bunlarÄ± aÃ§Ä±kÃ§a isteyin!
:::

### `filter()` iÃ§in daha fazla alÄ±ÅŸtÄ±rma

AÅŸaÄŸÄ±daki Ã¶zelliklere sahip uÃ§uÅŸlarÄ± bulun:

-   VarÄ±ÅŸta iki saat veya daha fazla gecikme olan

-   Houston'a (IAH veya HOU) uÃ§an

-   United, American veya Delta tarafÄ±ndan iÅŸletilen

-   Yaz aylarÄ±nda (Temmuz, AÄŸustos ve EylÃ¼l) kalkan

-   Ä°ki saatten fazla gecikmeli varan, ancak kalkÄ±ÅŸta gecikme olmayan

-   En az bir saat gecikmeli, ancak uÃ§uÅŸ sÄ±rasÄ±nda 30 dakikadan fazla telafi eden

-   Gece yarÄ±sÄ± ile sabah 6 arasÄ±nda (dahil) kalkan

Bir diÄŸer kullanÄ±ÅŸlÄ± `dplyr` filtreleme yardÄ±mcÄ±sÄ± `between()`'dÄ±r. Ne iÅŸe yarar? Ã–nceki sorularÄ± cevaplamak ve gereken kodu basitleÅŸtirmek iÃ§in kullanabilir misiniz?

KaÃ§ uÃ§uÅŸun `dep_time` deÄŸeri eksik? Hangi diÄŸer deÄŸiÅŸkenler eksik? Bu satÄ±rlar neyi temsil ediyor olabilir?

### 2. arrange()

arrange() fonksiyonu, filter() fonksiyonuna benzer ÅŸekilde Ã§alÄ±ÅŸÄ±r, ancak satÄ±rlarÄ± seÃ§mek yerine sÄ±ralarÄ±nÄ± deÄŸiÅŸtirir. Bu fonksiyon, sÄ±ralama iÅŸlemi iÃ§in bir veri Ã§erÃ§evesi ve bir dizi sÃ¼tun adÄ± (veya daha karmaÅŸÄ±k ifadeler) kullanÄ±r.

```{r}
flights |> 
  arrange(year, month, day) |> 
  head()
```

Azalan dÃ¼zende bir sÃ¼tuna gÃ¶re yeniden sÄ±ralamak iÃ§in `desc()` kullanÄ±n:

```{r}
flights |> 
  arrange(desc(dep_delay)) |> 
  head()
```

::: callout-note
ğŸ‘‹ Eksik deÄŸerler her zaman sonda sÄ±ralanÄ±r!
:::

#### **arrange iÃ§in daha fazla alÄ±ÅŸtÄ±rma**

-   TÃ¼m eksik deÄŸerleri baÅŸa sÄ±ralamak iÃ§in `arrange()` fonksiyonunu nasÄ±l kullanabilirsiniz? (Ä°pucu: `is.na()` kullanÄ±n).

-   UÃ§uÅŸlarÄ± en Ã§ok gecikmiÅŸ uÃ§uÅŸlarÄ± bulmak iÃ§in sÄ±ralayÄ±n. En erken kalkan uÃ§uÅŸlarÄ± bulun.

-   En hÄ±zlÄ± (en yÃ¼ksek hÄ±z) uÃ§uÅŸlarÄ± bulmak iÃ§in uÃ§uÅŸlarÄ± sÄ±ralayÄ±n.

-   Hangi uÃ§uÅŸlar en uzaÄŸa gitti? Hangileri en kÄ±sa mesafeyi kat etti?

### **3. `select()`**

YÃ¼zlerce hatta binlerce deÄŸiÅŸken iÃ§eren veri setlerine sahip olmak nadir deÄŸildir. Bu durumda, ilk zorluk genellikle gerÃ§ekten ilgilendiÄŸiniz deÄŸiÅŸkenlere odaklanmaktÄ±r. `select()` fonksiyonu, deÄŸiÅŸkenlerin adlarÄ±na dayalÄ± iÅŸlemler kullanarak yararlÄ± bir alt kÃ¼meye hÄ±zlÄ±ca odaklanmanÄ±zÄ± saÄŸlar.

```{r}
flights |> 
  select(year, month, day) |> 
  head()
```

`select()` iÃ§inde kullanabileceÄŸiniz bir dizi yardÄ±mcÄ± fonksiyon vardÄ±r:

-   `starts_with("abc")`: "abc" ile baÅŸlayan isimleri eÅŸleÅŸtirir.

-   `ends_with("xyz")`: "xyz" ile biten isimleri eÅŸleÅŸtirir.

-   `contains("ijk")`: "ijk" iÃ§eren isimleri eÅŸleÅŸtirir.

-   `matches("(.)\\1")`: dÃ¼zenli bir ifadeyle eÅŸleÅŸen deÄŸiÅŸkenleri seÃ§er. Bu, tekrarlanan karakterler iÃ§eren herhangi bir deÄŸiÅŸkenle eÅŸleÅŸir. DÃ¼zenli ifadeler hakkÄ±nda daha fazla bilgiyi diziler bÃ¶lÃ¼mÃ¼nde Ã¶ÄŸreneceksiniz.

-   `num_range("x", 1:3)`: x1, x2 ve x3 ile eÅŸleÅŸir.

Daha fazla ayrÄ±ntÄ± iÃ§in `?select` komutuna bakÄ±n.

::: callout-note
ğŸ‘‹ `select()` fonksiyonu deÄŸiÅŸkenleri yeniden adlandÄ±rmak iÃ§in kullanÄ±labilir, ancak aÃ§Ä±kÃ§a belirtilmeyen tÃ¼m deÄŸiÅŸkenleri kaldÄ±rdÄ±ÄŸÄ± iÃ§in nadiren kullanÄ±ÅŸlÄ±dÄ±r. Bunun yerine, aÃ§Ä±kÃ§a belirtilmeyen tÃ¼m deÄŸiÅŸkenleri koruyan bir `select()` Ã§eÅŸidi olan `rename()` fonksiyonunu kullanÄ±n.
:::

```{r}
flights |> 
  rename(tail_num = tailnum) |> 
  head()
```

::: callout-note
BaÅŸka bir seÃ§enek de `select()` fonksiyonunu `everything()` yardÄ±mcÄ±sÄ± ile birlikte kullanmaktÄ±r. Bu, veri Ã§erÃ§evesinin baÅŸÄ±na taÅŸÄ±mak istediÄŸiniz birkaÃ§ deÄŸiÅŸkeniniz varsa kullanÄ±ÅŸlÄ±dÄ±r.
:::

```{r}
flights |> 
  select(time_hour, air_time, everything()) |> 
  head()
```

### `select()` iÃ§in daha fazla alÄ±ÅŸtÄ±rma

-   `flights` veri setinden `dep_time`, `dep_delay`, `arr_time` ve `arr_delay` deÄŸiÅŸkenlerini seÃ§mek iÃ§in mÃ¼mkÃ¼n olduÄŸunca Ã§ok yol dÃ¼ÅŸÃ¼nÃ¼n.

-   Bir `select()` Ã§aÄŸrÄ±sÄ±nda bir deÄŸiÅŸkenin adÄ±nÄ± birden Ã§ok kez eklerseniz ne olur?

-   `any_of()` fonksiyonu ne iÅŸe yarar? Bu vektÃ¶rle birlikte neden yardÄ±mcÄ± olabilir?

```         
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
```

-   AÅŸaÄŸÄ±daki kodu Ã§alÄ±ÅŸtÄ±rmanÄ±n sonucu sizi ÅŸaÅŸÄ±rtÄ±yor mu? `select()` yardÄ±mcÄ±larÄ± varsayÄ±lan olarak bÃ¼yÃ¼k/kÃ¼Ã§Ã¼k harfle nasÄ±l baÅŸa Ã§Ä±kÄ±yor? Bu varsayÄ±lanÄ± nasÄ±l deÄŸiÅŸtirebilirsiniz?

```         
select(flights, contains("TIME"))
```

### `4. mutate()`

`mutate()` her zaman veri setinizin sonuna yeni sÃ¼tunlar ekler, bu nedenle yeni deÄŸiÅŸkenleri gÃ¶rebilmemiz iÃ§in daha dar bir veri seti oluÅŸturarak baÅŸlayacaÄŸÄ±z.

```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_time,
    hours = air_time /60,
    gain_per_hour = gain/hours
  )|> 
  head()
```

```{r}
flights_sml <- flights |> 
  select(year:day, 
         ends_with("delay"),
         distance,
         air_time, 
         arr_time,
         dep_time) |> 
  mutate(
    gain = dep_delay - arr_time,
    hours = air_time /60,
    gain_per_hour = gain/hours
  ) |> 
  arrange(desc(gain_per_hour)) |> 
  select(gain_per_hour, everything()) |> 
  filter(gain_per_hour > 400)

head(flights_sml)

```

EÄŸer sadece yeni deÄŸiÅŸkenleri tutmak istiyorsanÄ±z, `transmute()` fonksiyonunu kullanÄ±n:

```{r}
flights |> 
  transmute(
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours)|> 
  head()
```

### `mutate()` iÃ§in daha fazla alÄ±ÅŸtÄ±rma

-   Åu anda `dep_time` ve `sched_dep_time` deÄŸiÅŸkenlerine bakmak kolay, ancak gerÃ§ekte sÃ¼rekli sayÄ±lar olmadÄ±klarÄ± iÃ§in hesaplamalar yapmak zor. BunlarÄ± gece yarÄ±sÄ±ndan itibaren geÃ§en dakika sayÄ±sÄ±nÄ±n daha uygun bir gÃ¶sterimine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼n.

-   `air_time` ile `arr_time - dep_time` karÅŸÄ±laÅŸtÄ±rmasÄ±nÄ± yapÄ±n. Ne gÃ¶rmeyi bekliyorsunuz? Ne gÃ¶rÃ¼yorsunuz? DÃ¼zeltmek iÃ§in ne yapmanÄ±z gerekiyor?

-   `dep_time`, `sched_dep_time` ve `dep_delay` deÄŸiÅŸkenlerini karÅŸÄ±laÅŸtÄ±rÄ±n. Bu Ã¼Ã§ sayÄ±nÄ±n nasÄ±l iliÅŸkili olmasÄ±nÄ± beklersiniz?

-   Bir sÄ±ralama fonksiyonu kullanarak en Ã§ok gecikmeli 10 uÃ§uÅŸu bulun. EÅŸitlikleri nasÄ±l ele almak istiyorsunuz? `min_rank()` fonksiyonunun dokÃ¼mantasyonunu dikkatlice okuyun.

-   `1:3 + 1:10` ne dÃ¶ndÃ¼rÃ¼r? Neden?

-   R hangi trigonometrik fonksiyonlarÄ± saÄŸlar?

### `5. summarise()`

Son anahtar fiil `summarise()`'dÄ±r. Bir veri Ã§erÃ§evesini tek bir satÄ±ra daraltÄ±r:

```{r}
flights |> 
  summarise(delay=mean(dep_delay, na.rm = TRUE))
```

`summarise()` fonksiyonu, `group_by()` ile eÅŸleÅŸtirilmedikÃ§e Ã§ok kullanÄ±ÅŸlÄ± deÄŸildir. Bu, analiz birimini tÃ¼m veri setinden bireysel gruplara deÄŸiÅŸtirir.

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarise(delay = mean(dep_delay, na.rm = T))|> 
  head()
```

### Birden Ã§ok iÅŸlemi birleÅŸtirme

Her konum iÃ§in mesafe ve ortalama gecikme arasÄ±ndaki iliÅŸkiyi incelemek istediÄŸimizi hayal edin. `dplyr` hakkÄ±nda bildiklerinizi kullanarak ÅŸu ÅŸekilde bir kod yazabilirsiniz:

```{r}
flights %>% 
  group_by(dest) %>% 
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>% 
  filter(count > 20, dest != "HNL") |>  
  ggplot(aes(x = dist, y = delay)) +
  geom_point(aes(size = count), alpha = 1/3) +
  geom_smooth(se = FALSE)
#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'
# It looks like delays increase with distance up to ~750 miles 
# and then decrease. Maybe as flights get longer there's more 
# ability to make up delays in the air?
```

# DÃ¼zenli (Tidy) Veri ve R'da Veri DÃ¼zenleme

Veri dÃ¼zenleme, R'da verileri "dÃ¼zenli veri" (tidy data) adÄ± verilen bir sistem kullanarak tutarlÄ± bir ÅŸekilde organize etmeyi ifade eder. Verilerinizi bu formata getirmek baÅŸlangÄ±Ã§ta biraz Ã§aba gerektirir, ancak bu Ã§aba uzun vadede karÅŸÄ±lÄ±ÄŸÄ±nÄ± verir. DÃ¼zenli verilere ve `tidyverse` paketlerinin saÄŸladÄ±ÄŸÄ± dÃ¼zenli araÃ§lara sahip olduÄŸunuzda, verileri bir gÃ¶sterimden diÄŸerine dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in Ã§ok daha az zaman harcarsÄ±nÄ±z. BÃ¶ylece, Ã¶nemsediÄŸiniz veri sorularÄ±na daha fazla zaman ayÄ±rabilirsiniz.

Bir veri setini dÃ¼zenli hale getiren birbiriyle iliÅŸkili Ã¼Ã§ kural vardÄ±r:

-   Her deÄŸiÅŸken bir sÃ¼tundur; her sÃ¼tun bir deÄŸiÅŸkendir.

-   Her gÃ¶zlem bir satÄ±rdÄ±r; her satÄ±r bir gÃ¶zlemdir.

-   Her deÄŸer bir hÃ¼credir; her hÃ¼cre tek bir deÄŸerdir.

Bu kurallar, Ã§oÄŸu gerÃ§ek analizin en azÄ±ndan biraz dÃ¼zenleme gerektireceÄŸi anlamÄ±na gelir. Ä°ÅŸe temel deÄŸiÅŸkenlerin ve gÃ¶zlemlerin ne olduÄŸunu anlayarak baÅŸlarsÄ±nÄ±z. Bu bazen kolaydÄ±r; diÄŸer zamanlarda verileri orijinal olarak oluÅŸturan kiÅŸilere danÄ±ÅŸmanÄ±z gerekebilir. ArdÄ±ndan, verilerinizi sÃ¼tunlarda deÄŸiÅŸkenler ve satÄ±rlarda gÃ¶zlemler olacak ÅŸekilde dÃ¼zenli bir forma dÃ¶nÃ¼ÅŸtÃ¼rÃ¼rsÃ¼nÃ¼z.

`tidyr` paketi, verileri dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in iki fonksiyon saÄŸlar: `pivot_longer()` ve `pivot_wider()`. Ä°lk Ã¶nce `pivot_longer()` ile baÅŸlayacaÄŸÄ±z Ã§Ã¼nkÃ¼ en yaygÄ±n durum budur.

## `1. pivot_longer()`

`billboard` veri seti, 2000 yÄ±lÄ±ndaki ÅŸarkÄ±larÄ±n Billboard sÄ±ralamasÄ±nÄ± kaydeder:

```{r}
head(billboard)
```

Bu veri setinde her bir gÃ¶zlem bir ÅŸarkÄ±dÄ±r. Ä°lk Ã¼Ã§ sÃ¼tun (`artist`, `track` ve `date.entered`) ÅŸarkÄ±yÄ± tanÄ±mlayan deÄŸiÅŸkenlerdir. Sonra her hafta ÅŸarkÄ±nÄ±n sÄ±ralamasÄ±nÄ± tanÄ±mlayan 76 sÃ¼tunumuz (`wk1-wk76`) var. Burada, sÃ¼tun adlarÄ± bir deÄŸiÅŸkendir (hafta) ve hÃ¼cre deÄŸerleri baÅŸka bir deÄŸiÅŸkendir (sÄ±ralama).

Bu verileri dÃ¼zenlemek iÃ§in `pivot_longer()` fonksiyonunu kullanacaÄŸÄ±z:

```{r}
billboard |> 
  pivot_longer(
    cols = starts_with("wk"),
    names_to = "week",
    values_to = "rank",
    values_drop_na = TRUE
  )
```

Burada Ã¼Ã§ Ã¶nemli argÃ¼man vardÄ±r:

-   `cols`: Hangi sÃ¼tunlarÄ±n dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi gerektiÄŸini, yani hangi sÃ¼tunlarÄ±n deÄŸiÅŸken olmadÄ±ÄŸÄ±nÄ± belirtir. Bu argÃ¼man `select()` ile aynÄ± sÃ¶zdizimini kullanÄ±r, bu nedenle burada `!c(artist, track, date.entered)` veya `starts_with("wk")` kullanabiliriz.

-   `names_to`: SÃ¼tun adlarÄ±nda depolanan deÄŸiÅŸkeni adlandÄ±rÄ±r, biz bu deÄŸiÅŸkene `week` adÄ±nÄ± verdik.

-   `values_to`: HÃ¼cre deÄŸerlerinde depolanan deÄŸiÅŸkeni adlandÄ±rÄ±r, biz bu deÄŸiÅŸkene `rank` adÄ±nÄ± verdik.

-   `values_drop_na`: `TRUE`, NA'lÄ± satÄ±rlarÄ±n bÄ±rakÄ±ldÄ±ÄŸÄ± anlamÄ±na gelir.

::: callout-note
ğŸ‘‹ Kodda "week" ve "rank" kelimelerinin tÄ±rnak iÃ§inde olduÄŸuna dikkat edin Ã§Ã¼nkÃ¼ bunlar oluÅŸturduÄŸumuz yeni deÄŸiÅŸkenlerdir, `pivot_longer()` Ã§aÄŸrÄ±sÄ±nÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda henÃ¼z verilerde mevcut deÄŸillerdir.
:::

### BaÅŸka bir Ã¶rnek: pivot_longer()

SÃ¼tun adlarÄ±na sÄ±kÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ birden Ã§ok bilgi parÃ§asÄ±na sahip olduÄŸunuzda ve bunlarÄ± ayrÄ± yeni deÄŸiÅŸkenlerde depolamak istediÄŸinizde daha zorlu bir durum ortaya Ã§Ä±kar. Ã–rneÄŸin, `table1` ve `friends` tablolarÄ±nÄ±n kaynaÄŸÄ± olan `who2` veri setini ele alalÄ±m:

```{r}
head(who2)
```

DÃ¼nya SaÄŸlÄ±k Ã–rgÃ¼tÃ¼ tarafÄ±ndan toplanan bu veri seti, tÃ¼berkÃ¼loz teÅŸhisleri hakkÄ±nda bilgi kaydeder. Zaten deÄŸiÅŸken olan ve yorumlanmasÄ± kolay iki sÃ¼tun vardÄ±r: `country` ve `year`. BunlarÄ± `sp_m_014`, `ep_m_4554` ve `rel_m_3544` gibi 56 sÃ¼tun izler. Bu sÃ¼tunlara yeterince uzun sÃ¼re bakarsanÄ±z, bir kalÄ±p olduÄŸunu fark edeceksiniz. Her sÃ¼tun adÄ± \_ ile ayrÄ±lmÄ±ÅŸ Ã¼Ã§ parÃ§adan oluÅŸur. Ä°lk parÃ§a, `sp/rel/ep`, teÅŸhis iÃ§in kullanÄ±lan yÃ¶ntemi, ikinci parÃ§a, `m/f` cinsiyeti (bu veri setinde ikili bir deÄŸiÅŸken olarak kodlanmÄ±ÅŸtÄ±r) ve Ã¼Ã§Ã¼ncÃ¼ parÃ§a, `014/1524/2534/3544/4554/5564/65` yaÅŸ aralÄ±ÄŸÄ±nÄ± aÃ§Ä±klar (Ã¶rneÄŸin, 014, 0-14'Ã¼ temsil eder).

Yani bu durumda `who2`'de kaydedilmiÅŸ altÄ± bilgi parÃ§amÄ±z var: Ã¼lke ve yÄ±l (zaten sÃ¼tunlar); teÅŸhis yÃ¶ntemi, cinsiyet kategorisi ve yaÅŸ aralÄ±ÄŸÄ± kategorisi (diÄŸer sÃ¼tun adlarÄ±nda bulunur); ve bu kategorideki hasta sayÄ±sÄ± (hÃ¼cre deÄŸerleri). Bu altÄ± bilgi parÃ§asÄ±nÄ± altÄ± ayrÄ± sÃ¼tunda dÃ¼zenlemek iÃ§in, `names_to` iÃ§in bir sÃ¼tun adÄ± vektÃ¶rÃ¼ ve orijinal deÄŸiÅŸken adlarÄ±nÄ± `names_sep` iÃ§in parÃ§alara ayÄ±rmak Ã¼zere talimatlar ve `values_to` iÃ§in bir sÃ¼tun adÄ± ile `pivot_longer()` kullanÄ±rÄ±z:

```{r}
who2 |> 
  pivot_longer(
    cols = !(country:year),
    names_to = c("diagnosis", "gender", "age"),
    names_sep = "_",
    values_to = "count"
  )
```

## 2. Pivot_wider()

Åimdiye kadar, deÄŸerlerin sÃ¼tun adlarÄ±nda yer aldÄ±ÄŸÄ± yaygÄ±n sorun sÄ±nÄ±fÄ±nÄ± Ã§Ã¶zmek iÃ§in `pivot_longer()` kullandÄ±k. Åimdi, sÃ¼tunlarÄ± artÄ±rarak ve satÄ±rlarÄ± azaltarak veri setlerini daha geniÅŸ hale getiren `pivot_wider()`'a geÃ§eceÄŸiz (HA HA) ve tek bir gÃ¶zlemin birden Ã§ok satÄ±ra yayÄ±ldÄ±ÄŸÄ± durumlarda yardÄ±mcÄ± olur. Bu, gerÃ§ek hayatta daha az yaygÄ±n gibi gÃ¶rÃ¼nÃ¼yor, ancak hÃ¼kÃ¼met verileriyle uÄŸraÅŸÄ±rken Ã§ok ortaya Ã§Ä±kÄ±yor gibi gÃ¶rÃ¼nÃ¼yor.

HastalarÄ±n deneyimleri hakkÄ±nda veri toplayan Medicare ve Medicaid Hizmetleri Merkezleri'nden bir veri seti olan `cms_patient_experience`'a bakarak baÅŸlayacaÄŸÄ±z:

```{r}
head(cms_patient_experience)
```

Ä°ncelenen temel birim bir kuruluÅŸtur, ancak her kuruluÅŸ, anketteki her Ã¶lÃ§Ã¼m iÃ§in bir satÄ±r olmak Ã¼zere altÄ± satÄ±ra yayÄ±lmÄ±ÅŸtÄ±r. `measure_cd` ve `measure_title` iÃ§in tÃ¼m deÄŸer kÃ¼mesini `distinct()` kullanarak gÃ¶rebiliriz:

```{r}
cms_patient_experience |> 
  distinct(measure_cd, measure_title)
```

Bu sÃ¼tunlarÄ±n hiÃ§biri Ã¶zellikle harika deÄŸiÅŸken adlarÄ± oluÅŸturmaz: `measure_cd` deÄŸiÅŸkenin anlamÄ±na dair bir ipucu vermez ve `measure_title` boÅŸluklar iÃ§eren uzun bir cÃ¼mledir. Åimdilik yeni sÃ¼tun adlarÄ±mÄ±zÄ±n kaynaÄŸÄ± olarak `measure_cd`'yi kullanacaÄŸÄ±z, ancak gerÃ§ek bir analizde hem kÄ±sa hem de anlamlÄ± olan kendi deÄŸiÅŸken adlarÄ±nÄ±zÄ± oluÅŸturmak isteyebilirsiniz.

`pivot_wider()` fonksiyonu, `pivot_longer()`'a zÄ±t bir arayÃ¼ze sahiptir: yeni sÃ¼tun adlarÄ± seÃ§mek yerine, deÄŸerleri (`values_from`) ve sÃ¼tun adÄ±nÄ± (`names_from`) tanÄ±mlayan mevcut sÃ¼tunlarÄ± saÄŸlamamÄ±z gerekir:

```{r}
cms_patient_experience |> 
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  )
```

# Ä°liÅŸkisel Veri TablolarÄ±nÄ± BirleÅŸtirme

Bir veri analizinin yalnÄ±zca tek bir veri tablosu iÃ§ermesi nadirdir. Genellikle birÃ§ok veri tablonuz olur ve ilgilendiÄŸiniz sorularÄ± yanÄ±tlamak iÃ§in bunlarÄ± birleÅŸtirmeniz gerekir. Birden Ã§ok veri tablosu topluca iliÅŸkisel veri olarak adlandÄ±rÄ±lÄ±r, Ã§Ã¼nkÃ¼ Ã¶nemli olan yalnÄ±zca bireysel veri setleri deÄŸil, iliÅŸkilerdir.

Ä°liÅŸkisel verilerle Ã§alÄ±ÅŸmak iÃ§in tablo Ã§iftleriyle Ã§alÄ±ÅŸan fiillere ihtiyacÄ±nÄ±z vardÄ±r:

![](images/joins.png) **Ã–rnekler**

`dplyr`'daki iki tablolu fiilleri kullanarak `nycflights13`'ten iliÅŸkisel verileri inceleyeceÄŸiz.

![](images/flights.png)

`nycflights13` iÃ§in:

-   `flights`, `planes` tablosuna `tailnum` deÄŸiÅŸkeni aracÄ±lÄ±ÄŸÄ±yla baÄŸlanÄ±r.

-   `flights`, `airlines` tablosuna `carrier` deÄŸiÅŸkeni aracÄ±lÄ±ÄŸÄ±yla baÄŸlanÄ±r.

-   `flights`, `airports` tablosuna iki ÅŸekilde baÄŸlanÄ±r: `origin` ve `dest` deÄŸiÅŸkenleri aracÄ±lÄ±ÄŸÄ±yla.

-   `flights`, `weather` tablosuna `origin` (konum) ve `year`, `month`, `day` ve `hour` (zaman) deÄŸiÅŸkenleri aracÄ±lÄ±ÄŸÄ±yla baÄŸlanÄ±r.

## **`inner_join()`**

`flights` tablosunun ilk birkaÃ§ satÄ±rÄ±nÄ± incelersek, `carrier` sÃ¼tununun havayoluna karÅŸÄ±lÄ±k gelen iki karakterlik bir dize iÃ§erdiÄŸini gÃ¶zlemleriz.

```{r}
glimpse(flights)
```

`airlines` tablosunda, aynÄ± iki karakterlik dizelere sahibiz, ancak aynÄ± zamanda havayolunun tam adlarÄ±nÄ± da iÃ§eriyor.

```{r}
head(airlines)
```

Her uÃ§uÅŸun bir listesini ve her bir uÃ§uÅŸu yÃ¶neten havayollarÄ±nÄ±n tam adlarÄ±nÄ± almak iÃ§in, `flights` tablosundaki satÄ±rlarÄ±, her iki tabloda da `carrier` sÃ¼tunu iÃ§in karÅŸÄ±lÄ±k gelen deÄŸerlere sahip olan `airlines` tablosundaki satÄ±rlarla eÅŸleÅŸtirmemiz gerekir. Bu, `inner_join()` fonksiyonu ile gerÃ§ekleÅŸtirilir.

```{r}
flights_joined <- flights |> 
  inner_join(airlines, by= c("carrier"="carrier"))
glimpse(flights_joined)
```

`flights_joined` veri Ã§erÃ§evesinin artÄ±k `name` adlÄ± ek bir deÄŸiÅŸkene sahip olduÄŸuna dikkat edin. Bu, artÄ±k birleÅŸtirilmiÅŸ veri Ã§erÃ§evesine dahil edilen `airlines` tablosundan gelen sÃ¼tundur. Åifreli iki karakterlik kodlar yerine havayollarÄ±nÄ±n tam adlarÄ±nÄ± gÃ¶rÃ¼ntÃ¼leyebiliriz.

```{r}
flights_joined |> 
  select(carrier, name, flight, origin, dest) |> 
  head(3)
```

## **DÄ±ÅŸ BirleÅŸtirmeler (Outer Joins)**

Bir iÃ§ birleÅŸtirme (`inner join`), her iki tabloda da gÃ¶rÃ¼nen gÃ¶zlemleri tutar. Bir dÄ±ÅŸ birleÅŸtirme (`outer join`), tablolardan en az birinde gÃ¶rÃ¼nen gÃ¶zlemleri tutar. ÃœÃ§ tÃ¼r dÄ±ÅŸ birleÅŸtirme vardÄ±r:

-   Bir sol birleÅŸtirme (`left join`), `x`'deki tÃ¼m gÃ¶zlemleri tutar.

-   Bir saÄŸ birleÅŸtirme (`right join`), `y`'deki tÃ¼m gÃ¶zlemleri tutar.

-   Tam bir birleÅŸtirme (`full join`), `x` ve `y`'deki tÃ¼m gÃ¶zlemleri tutar.

### **`left_join()`**

`flights` ve `weather` tablolarÄ± ortak deÄŸiÅŸkenlerinde eÅŸleÅŸir: `year`, `month`, `day`, `hour` ve `origin`.

```{r}
flights_joined |> 
  left_join(weather)
```

```{r}
flights_joined |> 
  left_join(planes, by="tailnum")
```

## **Filtreleme BirleÅŸtirmeleri (Filtering Joins)**

Filtreleme birleÅŸtirmeleri, gÃ¶zlemleri deÄŸiÅŸtirme birleÅŸtirmeleriyle aynÄ± ÅŸekilde eÅŸleÅŸtirir, ancak deÄŸiÅŸkenleri deÄŸil, gÃ¶zlemleri etkiler. Ä°ki tÃ¼r vardÄ±r:

-   `semi_join(x, y)`, `y`'de eÅŸleÅŸmesi olan `x`'deki tÃ¼m gÃ¶zlemleri tutar.

-   `anti_join(x, y)`, `y`'de eÅŸleÅŸmesi olan `x`'deki tÃ¼m gÃ¶zlemleri bÄ±rakÄ±r.

YarÄ± birleÅŸtirmeler (`semi_join`), filtrelenmiÅŸ Ã¶zet tablolarÄ±nÄ± orijinal satÄ±rlarla eÅŸleÅŸtirmek iÃ§in kullanÄ±ÅŸlÄ±dÄ±r. Ã–rneÄŸin, en popÃ¼ler on varÄ±ÅŸ noktasÄ±nÄ± bulduÄŸunuzu hayal edin:

```{r}
top_dest <- flights |> 
  count(dest, sort=TRUE) |> 
  head(10)
```

```{r}
flights_joined |> 
  semi_join(top_dest)
```

Bir yarÄ± birleÅŸtirmenin tersi, bir karÅŸÄ± birleÅŸtirmedir (`anti_join`). Bir karÅŸÄ± birleÅŸtirme, eÅŸleÅŸmesi olmayan satÄ±rlarÄ± tutar. KarÅŸÄ± birleÅŸtirmeler, birleÅŸtirme uyuÅŸmazlÄ±klarÄ±nÄ± teÅŸhis etmek iÃ§in kullanÄ±ÅŸlÄ±dÄ±r. Ã–rneÄŸin, `flights` ve `planes` tablolarÄ±nÄ± birleÅŸtirirken, `planes` tablosunda eÅŸleÅŸmesi olmayan birÃ§ok uÃ§uÅŸ olduÄŸunu bilmek ilginizi Ã§ekebilir:

```{r}
flights |> 
  anti_join(planes, by = "tailnum") |> 
  count(tailnum, sort = TRUE)
```
